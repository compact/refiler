<?php

namespace Refiler;

/**
 * This class wraps around Sentry for use in Refiler.
 */
class Auth {
  // injected dependencies
  protected $config;
  protected $db;

  // Sentry User object
  protected $user;

  /**
   * Load Sentry and set the current user (if logged in).
   * @param array $config Must contain keys 'sentry_table_prefix' and
   *   'guest_permissions'.
   * @param DB    $db
   */
  public function __construct($config, DB $db) {
    // config
    $this->config = $config;

    // injected dependencies
    $this->db = $db;

    // load Sentry
    $this->load_sentry();

    // get user; Sentry::check() takes the longest time of the Sentry operations
    $this->user = Sentry::check() ? Sentry::getUser() : false;
  }

  /**
   * Load the Sentry class. This is a helper method for the constructor.
   */
  protected function load_sentry() {
    // autoload script generated by Composer
    require_once __DIR__ . '/../vendor/autoload.php';

    // alias the Sentry class
    if (!class_exists('Refiler\Sentry')) {
      class_alias('\Cartalyst\Sentry\Facades\Native\Sentry', 'Refiler\Sentry');
    }

    // connect the database to Sentry
    // the following call doesn't work with the table prefix argument due to a
    // Sentry issue: https://github.com/cartalyst/sentry/issues/210
    // Sentry::setupDatabaseResolver($db->get_PDO(), null, $table_prefix);
    $resolver = new \Cartalyst\Sentry\Facades\ConnectionResolver(
      $this->db->get_PDO(),
      $this->db->get_PDO()->getAttribute(\PDO::ATTR_DRIVER_NAME)
    );
    $resolver->getConnection()->setTablePrefix(
      $this->config['sentry_table_prefix']
    );
    \Illuminate\Database\Eloquent\Model::setConnectionResolver($resolver);

    // disable the throttling feature; doing this has a nice side effect of
    // Sentry::check() taking a little less time
    Sentry::getThrottleProvider()->disable();
  }

  /**
   * Use this method in cases where the user isn't already logged in.
   * @param \Cartalyst\Sentry\Users\UserInterface $user
   */
  public function set_user($user) {
    $this->user = $user;
  }

  /**
   * @return boolean Whether the user is logged in.
   */
  public function logged_in() {
    return $this->user !== false;
  }

  /**
   * @param  string  $permission Key.
   * @return boolean Whether the user has the given permission.
   */
  public function has_permission($permission) {
    // hasAccess() is broader than hasPermission()
    return $this->user
      ? $this->user->hasAccess($permission)
      : $this->config['guest_permissions'][$permission];
  }

  /**
   * Sentry stores 1 for allow and -1 for deny. We convert these values for
   *   JSON output.
   * @return array
   */
  public static function encode_permissions($permissions) {
    return array_map(function ($permission) {
      return $permission === 1 ? true : false;
    }, $permissions);
  }

  /**
   * Inverse of decode_permissions().
   * @return array
   */
  public static function decode_permissions($permissions) {
    return array_map(function ($permission) {
      return $permission === 'true' ? 1 : -1;
    }, $permissions);
  }

  /**
   * @return array The permissions of the current user.
   */
  public function get_permissions() {
    return $this->user
      ? self::encode_permissions($this->user->getMergedPermissions())
      : $this->config['guest_permissions'];
  }

  /**
   * @return array Array of the current user's data, intended for JSON-encoded
   *   output.
   */
  public function get_array() {
    return array(
      'loggedIn' => $this->logged_in(),
      'permissions' => $this->get_permissions()
    );
  }

  /**
   * Should be called only by admins.
   * @return array[] Data of all users.
   */
  public function get_user_arrays() {
    $users = Sentry::findAllUsers();
    $user_arrays = array();

    foreach ($users as $user) {
      $user_array = array(
        'id' => $user->getId(),
        'email' => $user->email,
        'permissions' => self::encode_permissions($user->getMergedPermissions())
      );
      if (!$user->isActivated()) {
        // getActivationCode() generates a new activation code; an existing
        // activation code is stored in $user->activation_code
        $user_array['activationCode'] = !empty($user->activation_code)
          ? $user->activation_code : $user->getActivationCode();
      }

      $user_arrays[] = $user_array;
    }

    return $user_arrays;
  }
}